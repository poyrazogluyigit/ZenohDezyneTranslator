SORU: yaptigimiz is mantikli mi?
biz bir api olusturuyoruz ve runtime da model checking yapiyoruz.
model sabit degil mi? compile time da belli olan bir sey degil mi? 
dolayisiyla bu yaklasim inefektif kalmayacak mi?

potansiyel cevap 1:
evet. 

potansiyel cevap 2:
scope u runtime'da sabit kalan sistemlere yonlendirebiliriz.
o durumda bile bu wrapper'in katkisi kodda NEREDEYSE hicbir degisiklik
yapmadan model checkinge izin vermek olur. bu toolu efektif kilabilmek icin 
degisiklik isini mumkun mertebe sinirlamaliyiz.

THIS IS A FAIRLY COMMON ASSUMPTION

---------------------------------------------------

KULLANICIDAN STATE TRANSITION YAZMASINI ISTEDIK YA,
BUNU BIR CESIT CONFIG DOSYASINDAN isteyebiliriz
MESELA JSON
her jsonda node'a parametre.

json dosyasini kodu kosmadan okuyabiliriz

biz bunu cok uzatirsak zaten istedigimiz her bilgiyi assume etmis olduk ki

---------------------------------------------------

literature review:
runtime model checking
handbook of model checking
survey of model checkersl

------------------------------------------------------

SORU 2: yazilmis koddan model insa edilir mi (state behavior u elle girdirmek
yerine)

if possible, future work

----------------------------------
Bize state in ne zaman degistigini de gormek lazim

state is probably an enum
is this enum defined at compile time?

bunu belirlemek icin states = {..., ..., ...} gerekebilir

SORU 3: State galiba sadece elle gomulebilir. Bastan define edilmis bir
stateler kumesi olmali. Bunu otomatik olarak yapabilir miyiz ki?

State gommek icin secenekler:

1 - state registry tamamiyla elle degistiriliyor
wrapper.addState(), wrapper.setState()

burada bir sikinti var: setState() in nereden cagirildigini bilmemiz gerekiyor. Bunu runtime'da ogren-
mek icin ekstra sistemler implement etmek gerekir.

2 - state registry yine elle degistiriliyor ancak pub/sub koduna gomulu
declare_subscriber(*args, **kwargs, prevState = None, nextState = None)

3 - 2 icin potansiyel syntactic sugar
wrapper.setInitialState()
declare_subscriber(*args, **kwargs, nextState = wrapper.currentState)
pub(*args, **kwargs, nextState = wrapper.currentState)

setInitialState enum declaration'a gomulebilir.
en mantiklisi 3 gibi ama prevstate bilgisi yine de yazilimci icin isi kolaylastirabilir.

SORU 4: transition logic i nasil cekecegim?
her state i kaydettim. ayrica her transitionu da kaydetmeliyim 
(orn.
    eger pub -> /demo/example kaydet (pub, /demo/example, currentState, nextState)
    eger sub -> /demo/example kaydet (sub, /demo/example, currentState, nextState)
)
---------------------------------------------------
invariant declaration api
declare_invariant(state, property) ? 

simdi burada soyle sikintilar var:
su andaki haliyle biz sadece incoming/outgoing iletisimde state degisimini trackleriz. 
bunu kisitlamayan herhangi bir invarianti ben napim
ama mesela, declare_invariant(RUNNING, (currentState != IDLE)) kasa bir statement gelir mi veya formule
edilebilir mi
yani; ben aslinda su anda dezyne'a sadece state logic'i geciriyorum. dolayisiyla sadece onu trackleyebilirim.
bir node simdilik kafamda atomic bir dezyne component'a translate ediyor, dolayisiyla baska parcalarla iliskisini
nasil yazacagiz?

--------------------------------------------------------
devam
eger state bilgisi girilmezse nasil olacak? 
eger state degismiyorsa transition tutmaya gerek var mi?
wrapper'da currentState takip etmek mantikli mi? 
cevap: belki mantikli olabilir. control flow'da girilebilecek farkli stateleri bu sayede represent etmis
oluyorsun. 
ama soyle; iki sekilde yapilabilir: birincisi currentstate tutacaksin. ikincisi, her pub/sub/put declarationda currentState ve next state isteyip transitionlari
oradan cikaracaksin.

ya current state tuttugumda kod generation isini biraz sikintiya sokmuyor mu. zira bu takdirde transitionun nereden oldugu bilgisi runtime dependent ve gozlemci sistemime
asikar degil.

SORUN
su anda yaptigimda incoming messagelarda esnek transition yok. that is, sadece bir kere declare ediyorsun ve o suba her geldiginde ayni state transitionu yapmali.
bu nasil asilabilir?
birincisi, callback declare etmek icin handle yazilabilir. 
oyle bir handle yaziyorsun ki aslinda senin handle'in callback oluyor ancak currentState'e bagli olarak farkli seyler calistiriyor.
boylece farkli statelere farkli callbackler ekleyebilmis oluyorsun
switch-case moment
idk really
BU ONEMLI YA.


* STATE biz arkada state logici paralel nodeda calistiriyoruz
*
*


SORU
bu dediklerimle state invariantlari uyumlu mu?????
yani su sekil: state invariant fikri su anda control flowdan tamamen bagimsiz gibi. yani bir yere state != x yazabilirsin ama
bu universal gecerli olur. bunun kendi logicini nasil yazdiricam
more specifically, her state'de modelleyebildigim iki degisken var: currentState (trivial) ve nextState.
dolayisiyla yazabilecegim butun invariantlar su sekilde:
if (not) nextState
if (not) currentState -> kuvvetle muhtemel bu control flow uzerine assumptionlardan bina ediliyor,
dolayisiyla kuvvetle muhtemel sadece nextState uzerine invariantlar declare edebilirim.


---------------------------------------------
notlar:

state variablelar kullanmak isteyecek onun icin ayri declare edebiliriz.

declare_state_change(STATE)
bunun icin isimli condition blocklari vermek gerekebiliyor.
ayri bir yerde condition declare ettirmek gerekebiliyor:
declare_cond(condition, next_state);

declare_event(); -> custom event tanimlamaya izin

TODO:
[ ] dezyne variablelarini zenoh'a maplemenin bir yolunu arastirmak gerekiyor.
[ ] dezyne guardlarin ne kadarina izin veriyor?
[ ] inevitable ve optional kullanimini ekle
[ ] guardlarda otherwise arastir

# Dezyne degisken tipleri

bool, enum, subint
bool: true, false
!b
b1 && b2
b1 || b2
b1 == b2
b1 != b2

enum: c misali
e1 == e2
e1 != e2
v.ENUM (v = enum.ENUM)

subint: ranged integers
subint int {-1..2}
comparison, addition and subtraction are supported.
note: integers of different subint types can be used in comparison, assignment, and function calls.
the verifier will check that the resulting integer value is within the defined subint range.

extern types are not supported by any verification machinery and are only used for code generation.

GUARD:
    sadece bool expression aliyor.
    bool-expression ::= bool-literal 
                        | bool-variable 
                        | action 
                        | call 
                        | field-test 
                        | ! bool-expression 
                        | ( bool-expression )
                        | bool-expression bool-operator bool-expression
                        | int-expression comparison-operator int-expression
    
    bool-variable ::= identifier | port . identifier
    bool-literal ::= false | true
    field-test ::= enum-variable . enum-field
    enum-variable ::= bool-variable 
    bool-operator ::= == 
                      | !=
                      | &&
                      | ||
    comparison-operator ::= ==
                            | !=
                            | <= 
                            | >= 
                            | <
                            | >

    where action and call are type bool.

    int-expression ::= int-literal
                        | subint-variable
                        | action
                        | call
                        | "-" int-expression
                        | "(" int-expression ")"
                        | int-expression int-operator int-expression
    subint-variable ::= identifier | port "." identifier
    int-literal ::= "-"? [0-9]+
    int-operator ::= "+" | "-"

    where action and call are of a subint type

yani ideal olarak yapilabilecek sey dil icinde enum, subint ve bool destegi saglayip bu sekilde declare
edilmis her degiskeni donusturmek.
cpp typed oldugu icin kendi tipimizi tanimlar ve bunu yapariz. ancak python icin bu o kadar kolay olmayabilir 
zira python typed degil.
