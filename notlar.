SORU: yaptigimiz is mantikli mi?
biz bir api olusturuyoruz ve runtime da model checking yapiyoruz.
model sabit degil mi? compile time da belli olan bir sey degil mi? 
dolayisiyla bu yaklasim inefektif kalmayacak mi?

potansiyel cevap 1:
evet. 

potansiyel cevap 2:
scope u runtime'da sabit kalan sistemlere yonlendirebiliriz.
o durumda bile bu wrapper'in katkisi kodda NEREDEYSE hicbir degisiklik
yapmadan model checkinge izin vermek olur. bu toolu efektif kilabilmek icin 
degisiklik isini mumkun mertebe sinirlamaliyiz.

THIS IS A FAIRLY COMMON ASSUMPTION

---------------------------------------------------

KULLANICIDAN STATE TRANSITION YAZMASINI ISTEDIK YA,
BUNU BIR CESIT CONFIG DOSYASINDAN isteyebiliriz
MESELA JSON
her jsonda node'a parametre.

json dosyasini kodu kosmadan okuyabiliriz

biz bunu cok uzatirsak zaten istedigimiz her bilgiyi assume etmis olduk ki

---------------------------------------------------

literature review:
runtime model checking
handbook of model checking
survey of model checkersl

------------------------------------------------------

SORU 2: yazilmis koddan model insa edilir mi (state behavior u elle girdirmek
yerine)

if possible, future work

----------------------------------
Bize state in ne zaman degistigini de gormek lazim

state is probably an enum
is this enum defined at compile time?

bunu belirlemek icin states = {..., ..., ...} gerekebilir

SORU 3: State galiba sadece elle gomulebilir. Bastan define edilmis bir
stateler kumesi olmali. Bunu otomatik olarak yapabilir miyiz ki?

State gommek icin secenekler:

1 - state registry tamamiyla elle degistiriliyor
wrapper.addState(), wrapper.setState()

burada bir sikinti var: setState() in nereden cagirildigini bilmemiz gerekiyor. Bunu runtime'da ogren-
mek icin ekstra sistemler implement etmek gerekir.

2 - state registry yine elle degistiriliyor ancak pub/sub koduna gomulu
declare_subscriber(*args, **kwargs, prevState = None, nextState = None)

3 - 2 icin potansiyel syntactic sugar
wrapper.setInitialState()
declare_subscriber(*args, **kwargs, nextState = wrapper.currentState)
pub(*args, **kwargs, nextState = wrapper.currentState)

setInitialState enum declaration'a gomulebilir.
en mantiklisi 3 gibi ama prevstate bilgisi yine de yazilimci icin isi kolaylastirabilir.

SORU 4: transition logic i nasil cekecegim?
her state i kaydettim. ayrica her transitionu da kaydetmeliyim 
(orn.
    eger pub -> /demo/example kaydet (pub, /demo/example, currentState, nextState)
    eger sub -> /demo/example kaydet (sub, /demo/example, currentState, nextState)
)
---------------------------------------------------
invariant declaration api
declare_invariant(state, property) ? 

simdi burada soyle sikintilar var:
su andaki haliyle biz sadece incoming/outgoing iletisimde state degisimini trackleriz. 
bunu kisitlamayan herhangi bir invarianti ben napim
ama mesela, declare_invariant(RUNNING, (currentState != IDLE)) kasa bir statement gelir mi veya formule
edilebilir mi
yani; ben aslinda su anda dezyne'a sadece state logic'i geciriyorum. dolayisiyla sadece onu trackleyebilirim.
bir node simdilik kafamda atomic bir dezyne component'a translate ediyor, dolayisiyla baska parcalarla iliskisini
nasil yazacagiz?

--------------------------------------------------------
devam
eger state bilgisi girilmezse nasil olacak? 
eger state degismiyorsa transition tutmaya gerek var mi?
wrapper'da currentState takip etmek mantikli mi? 
cevap: belki mantikli olabilir. control flow'da girilebilecek farkli stateleri bu sayede represent etmis
oluyorsun. 
ama soyle; iki sekilde yapilabilir: birincisi currentstate tutacaksin. ikincisi, her pub/sub/put declarationda currentState ve next state isteyip transitionlari
oradan cikaracaksin.

ya current state tuttugumda kod generation isini biraz sikintiya sokmuyor mu. zira bu takdirde transitionun nereden oldugu bilgisi runtime dependent ve gozlemci sistemime
asikar degil.

SORUN
su anda yaptigimda incoming messagelarda esnek transition yok. that is, sadece bir kere declare ediyorsun ve o suba her geldiginde ayni state transitionu yapmali.
bu nasil asilabilir?
birincisi, callback declare etmek icin handle yazilabilir. 
oyle bir handle yaziyorsun ki aslinda senin handle'in callback oluyor ancak currentState'e bagli olarak farkli seyler calistiriyor.
boylece farkli statelere farkli callbackler ekleyebilmis oluyorsun
switch-case moment
idk really
BU ONEMLI YA.


* STATE biz arkada state logici paralel nodeda calistiriyoruz
*
*


SORU
bu dediklerimle state invariantlari uyumlu mu?????
yani su sekil: state invariant fikri su anda control flowdan tamamen bagimsiz gibi. yani bir yere state != x yazabilirsin ama
bu universal gecerli olur. bunun kendi logicini nasil yazdiricam
more specifically, her state'de modelleyebildigim iki degisken var: currentState (trivial) ve nextState.
dolayisiyla yazabilecegim butun invariantlar su sekilde:
if (not) nextState
if (not) currentState -> kuvvetle muhtemel bu control flow uzerine assumptionlardan bina ediliyor,
dolayisiyla kuvvetle muhtemel sadece nextState uzerine invariantlar declare edebilirim.


---------------------------------------------
notlar:

state variablelar kullanmak isteyecek onun icin ayri declare edebiliriz.

declare_state_change(STATE)
bunun icin isimli condition blocklari vermek gerekebiliyor.
ayri bir yerde condition declare ettirmek gerekebiliyor:
declare_cond(condition, next_state);

declare_event(); -> custom event tanimlamaya izin

TODO:

## Dezyne alakali

[ ] dezyne variablelarini zenoh'a maplemenin bir yolunu arastirmak gerekiyor.
[x] dezyne guardlarin ne kadarina izin veriyor?
[ ] inevitable ve optional kullanimini ekle
[ ] guardlarda otherwise arastir

## Kod alakali
[x] Kodu C++'a gecir
[ ] C++'da query reply metotlarini dene

# Dezyne degisken tipleri

bool, enum, subint
bool: true, false
!b
b1 && b2
b1 || b2
b1 == b2
b1 != b2

enum: c misali
e1 == e2
e1 != e2
v.ENUM (v = enum.ENUM)

subint: ranged integers
subint int {-1..2}
comparison, addition and subtraction are supported.
note: integers of different subint types can be used in comparison, assignment, and function calls.
the verifier will check that the resulting integer value is within the defined subint range.

extern types are not supported by any verification machinery and are only used for code generation.

GUARD:
    sadece bool expression aliyor.
    bool-expression ::= bool-literal 
                        | bool-variable 
                        | action 
                        | call 
                        | field-test 
                        | ! bool-expression 
                        | ( bool-expression )
                        | bool-expression bool-operator bool-expression
                        | int-expression comparison-operator int-expression
    
    bool-variable ::= identifier | port . identifier
    bool-literal ::= false | true
    field-test ::= enum-variable . enum-field
    enum-variable ::= bool-variable 
    bool-operator ::= == 
                      | !=
                      | &&
                      | ||
    comparison-operator ::= ==
                            | !=
                            | <= 
                            | >= 
                            | <
                            | >

    where action and call are type bool.

    int-expression ::= int-literal
                        | subint-variable
                        | action
                        | call
                        | "-" int-expression
                        | "(" int-expression ")"
                        | int-expression int-operator int-expression
    subint-variable ::= identifier | port "." identifier
    int-literal ::= "-"? [0-9]+
    int-operator ::= "+" | "-"

    where action and call are of a subint type

yani ideal olarak yapilabilecek sey dil icinde enum, subint ve bool destegi saglayip bu sekilde declare
edilmis her degiskeni donusturmek.
cpp typed oldugu icin kendi tipimizi tanimlar ve bunu yapariz. ancak python icin bu o kadar kolay olmayabilir 
zira python typed degil.


## 20 Oct

gpt diyor ki bu is dataflow/symbolic analysis demektir.

What are the use cases?

wrapper.declare_publisher("demo/node/1")
// this would mean that the boolean expression is added as an invariant
// to the READY state.
wrapper.set_invariant(isInitialized && isConnected, state.READY)
// question: do we need to track these variables?
// (if yes, we may require each transition to be encoded by hand)
// bence her state'de bu degiskenlere ne oluyor bilmek gerekecek.
// example:

[state.INITIALIZING] {
    inevitable: {
        isInitialized = true;
        state = state.CONNECTING;
    }
}
[state.CONNECTING]{
    inevitable: {
        isConnected = true;
        state = state.READY;
    }
}

[state.READY] {
    invariant isInitialized && isConnected;
}

// i have state variables. the invariants depend on the state variables.
// the state variables are useless if they never change, thus they change in
// at least one execution flow.

gpt'nin onerdigi sey trace analysis oluyor, bu yoldan gidersek gitgide runtime verification'a
converge ediyoruz.

conjectures: sunlari diyebilir miyiz?
1 - model checking runtime'dan bagimsizdir
2 - model checking tamamen statiktir

1 -> o zaman runtime'a bagimli bir veri model checking'de kullanilmaz
-> degisken/state takip metodumuz runtime'a bagimli olamaz (*)

3 - degiskenler runtime'a baglidir
-> degiskenin runtime'dan bagimsiz bir analizini yapmak icin alabilecegi butun degerleri
bilmek gerekir (**)

(*), (**) -> model checking yapabilmek icin bir degisken alabilecegi butun degerleri bilmemiz gerekir 
()

## Plan (big picture)

- Minimal programmer changes:
    - Mark which variables and events are relevant (small macros / one-line calls).
    - Optionally annotate event names on callbacks.

- Runtime: StateTracker observes:
    - Event occurrences (named events).
    - Current valuations of tracked variables (finite domains).
    - Timestamps / ordering (to separate transitions).

- After collecting many runs (or exploring via test harness), build an abstract transition system:
    -Each unique valuation of tracked variables → candidate state node.
    -Each observed event from state A to state B → transition labeled by event.

- Post-process:
    - Collapse equivalent states (minimization / heuristics).
    - Abstract infinite domains into finite labels (bucketing).
    - Add non-determinism where different outcomes observed for same input.

- Emit Dezyne model (interfaces, states, transitions).

- Feed to Dezyne for model checking; iterate (refine instrumentation / abstraction).


chatgpt bunu oneriyor. burada zenoh'la alakali bir sey yok ama eklenebilir mi?










## 23 ekim 2025

onden tracklenen degiskenleri ve butun transitionlari isteyecegiz.
burada dezyne'a mantigi yazabilmek icin degiskenin nerelerde nasil degistigini 
de istemek gerekir mi? haftaya gorecegiz.

orn.

subint x{0...21};
bool y = false;

add_transition([](){(x > 3) || y}, state.A, state.B)

dogan hoca: proposition std::function olsun, alinca execute et.

TODO: 
[ ] genel closures fikri, cpp closures arastir
[ ] cpp bool ve enum overload, arastir
[ ] yukarida tarif ettigim yaklasimi implement etmeye calis
[ ] dezyne arka plan model checking mekanizmalarini bi arastir

sirketler: verum, ivex

pl isi icin lean bak misal.
sonra, ragel
s-expression (lisp, haskell, ocaml, scheme (lol))
programming languages theory

